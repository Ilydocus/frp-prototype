{-# LANGUAGE ScopedTypeVariables #-}
module Main (main) where

import Control.Exception
import Control.Applicative
import Network.Socket hiding (send, recv)
import Network.Socket.ByteString.Lazy
--import System.Random

import RrcMessages

import Control.Concurrent.Async

import Data.Time
import Text.Printf

import Reactive.Banana as R
import Reactive.Banana.Frameworks as R

import System.IO

import Control.Monad

main :: IO ()
main =
  withSocketsDo $ do    
    
    startTime <- getCurrentTime
    ues <- mapM (async . powerOn) [1..1] --nb of UEs
    mapM_ wait ues
    endTime <- getCurrentTime
    
    let diff = endTime `diffUTCTime` startTime
    printf "Time for the UEs procedures: %s\n"  (show diff)

powerOn :: Int -> IO ()
powerOn ueId =
  bracket (connectedSocket "127.0.0.1" "43000")
          close powerOn'
  where
    powerOn' :: Socket -> IO ()
    powerOn' sock = do
      --create sources
      sources <- newAddHandler
      --compile and start network
      network <- compile $ setupNetwork sources
      actuate network
      -- specific event loop
      eventLoop sources sock ueId
      --_ <- send sock $ encode (RAPreamble ueId)
      
      --randomId <- randomRIO (1, 320 :: Int)
      -- _ <- send sock $ encode (RAPreamble randomId)
      -- RAResponse _ <- decode <$> recv sock 10240
      --_ <- send sock $ encode (RRCConnectionRequest (RRCConnectionRequestIEs (STMSI ueId) Emergency 2))

      --RRCConnectionSetup _ <- decode <$> recv sock 10240
      --_ <- send sock $ encode (RRCConnectionComplete True)
      return ()

connectedSocket :: HostName -> ServiceName -> IO Socket
connectedSocket host port = do
  sock <- socket AF_INET Stream defaultProtocol
  addrInfo <- getAddrInfo Nothing (Just host) (Just port)
  let primary = head addrInfo
  connect sock $ addrAddress primary
  return sock

--Read commands and fire corresponding events (Approximation nb1)
eventLoop :: EventSource (RrcMessage,Socket)-> Socket-> Int -> IO ()
eventLoop message  sock ueId = loop
   where
     loop = withSocketsDo $ do
       --Send first message
       --fire message (RAPreamble 47,sock) --forkIO
       _ <- send sock $ encode (RAPreamble RA_RNTI ueId)
       --Wait for response
       forever $ do
         messDec <- decode <$> recv sock 1024
         fire message (messDec,sock) --forkIO?
         --send sock $ encode (RAPreamble 45)--non execute
         
      {- putStr "> "
       hFlush stdout
       s <- getLine
       case s of
         "message1" -> fire message 1 --fire corresponding events
         "message2" -> fire message 2
         "messageI" -> fire messageI ()
         "quit" -> return ()
         _ -> putStrLn "Unknown command"
       when (s /= "quit") loop -}
{-----------------------------------------------------
     Event Sources
------------------------------------------------------}
type EventSource a = (AddHandler a, a -> IO())

addHandler :: EventSource a -> AddHandler a
addHandler = fst

fire :: EventSource a -> a -> IO()
fire = snd

{-----------------------------------------------------
     Program Logic
------------------------------------------------------}

-- Set up the event network
setupNetwork :: forall t. Frameworks t =>
   EventSource (RrcMessage,Socket) -> Moment t ()
setupNetwork message = do

  --Obtain events corresponding to the eNodeB
  eMessage{-:: Event t (RrcMessage,Socket) -}<- fromAddHandler (addHandler message)
  
  let{-
    --How to capture the state? Compare to the slot machine
    --For now, number of messages received is the state
    -- both the eMessage 1 and the emessage2 events add one to the state
    bNbMessages :: Behavior t Int
    eNbMessages :: Event t Int
    (eNbMessages, bNbMessages) = mapAccum 0 . fmap (\f x -> (f x, f x)) $
                     (addMessage <$ eMessage)
                        
    --Functions to change the state
    addMessage = (+ 1)-}
    
  --Fire a specific event depending on the type of message
  --let eMessageRAResponse ::Event t (RrcMessage,Socket)
  {-case fst eMessage of
    (RAResponse a b c, _) -> do
      let
        --eMessageRAResponse ::Event t (RrcMessage,Socket)
        eMessageRAResponse = filterE raResponse eMessage
        raResponse:: (RrcMessage, Socket)-> Bool
        raResponse x = case x of
          (RAResponse a b c, _)-> True
          _ -> False
      reactimate $ sendResponse  <$> eMessageRAResponse
      --return ()
    (RRCConnectionSetup a b c, _) -> do
      eMessageRrcCS <- filterE (\t ->True) eMessage
      reactimate $ sendResponse2  <$> eMessageRrcCS
    -}
    
    --Inner functions depending on the incoming event
    eMessageRAResponse ::Event t (RrcMessage,Socket)
    eMessageRAResponse = filterE raResponse eMessage

    raResponse:: (RrcMessage, Socket)-> Bool
    raResponse x = case x of
      (RAResponse a b c, _)-> True
      _ -> False

    eMessageRrcCS ::Event t (RrcMessage,Socket)
    eMessageRrcCS = filterE rrcCS eMessage

    rrcCS:: (RrcMessage, Socket)-> Bool
    rrcCS x = case x of
      (RRCConnectionSetup a b c, _)-> True
      _ -> False

    --Test
    eMessageRAP ::Event t (RrcMessage,Socket)
    eMessageRAP = filterE raPr eMessage

    raPr:: (RrcMessage, Socket)-> Bool
    raPr x = case x of
      (RAPreamble a b, _)-> True
      _ -> False
     

    --Output: Is printed in the order of definition?
  --reactimate $ putStrLn . showNbMessages <$> eNbMessages
  reactimate $ putStrLn . showMessageNumber <$> eMessage
  --reactimate $ putStrLn . show <$> eMessage
    --add an output event?
  reactimate $ sendResponse  <$> eMessageRAResponse
  --reactimate $ sendResponse2  <$> eMessageRAP
  --reactimate $ putStrLn "RAResponse has been identified"<$ eMessageRAResponse
  reactimate $ sendResponse2  <$> eMessageRrcCS

    
showNbMessages nbMessages = "Nb of messages received in this UE: " ++ show nbMessages
showMessageNumber (number,sock) = "Message " ++ show number ++ " from eNodeB has arrived"

sendResponse  (number,sock) = do
                             _ <- send sock $ encode (RRCConnectionRequest C_RNTI 3 "45")
                             putStrLn "Sends something"
                             return ()

sendResponse2  (number,sock) = do
                             _ <- send sock $ encode (RRCConnectionSetupComplete "4")
                             putStrLn "Sends something CS Complete"
                             return ()
