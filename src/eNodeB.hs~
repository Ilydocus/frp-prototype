{-# LANGUAGE ScopedTypeVariables #-} --allows "forall t. NetworkDescription t"
module Main (main) where

import Control.Monad (when)
import System.IO

import Reactive.Banana as R
import Reactive.Banana.Frameworks as R

--Socket related
import Network hiding (accept)
import Network.Socket hiding (send, recv)
import Network.Socket.ByteString.Lazy

import Control.Concurrent
import Control.Concurrent.STM
import Control.Monad
import Control.Exception

import qualified Data.Map.Lazy as Map

import RrcMessages
import S1Messages

import Identifiers
import UeContextStates as Context

type ENBMap = Map.Map Int UeContext_eNB


main :: IO ()
main = do
  sources <- makeSources --see if changes needed
  eNBMap <- newTVarIO Map.empty
  network <- compile $ setupNetwork sources (return eNBMap)
  actuate network
  eventLoop sources -- pourquoi a la fin?

--Create event sources corresponding to UeMessages MMEMessages Database
makeSources = (,,) <$> newAddHandler <*> newAddHandler <*> newAddHandler

--Read commands and fire corresponding events (Approximation nb1)
eventLoop :: (EventSource (RrcMessage, Socket,Socket), EventSource (S1APMessage,Socket),EventSource (TVar ENBMap))-> IO ()
eventLoop (messageUE, messageMME, messageDatabase) = loop
   where
     loop = withSocketsDo $ do
       --eNBMap <- newTVarIO Map.empty
       listenSocket <- listenOn $ PortNumber 43000
       --(connectionSocket, _) <- accept listenSocket
       forever $ do
         --listenSocket <- listenOn $ PortNumber 43000
         (connectionSocket, _) <- accept listenSocket
         forkIO $ do
          bracket (connectedMMESocket "127.0.0.1" "43001")
                  close (powerMME connectionSocket)
          where
            powerMME :: Socket  -> Socket -> IO ()
            powerMME ueSock mmeSock = do --mettre type function
                    --first message M
             --(fire messageMME (GetSocket,mmeSock))
             --_ <- send mmeSock $ encode (S1APInitialUEMessage 12 EPSAttach "16")
             --_ <- send ueSock $ encode (RAResponse RA_RNTI 12 21)
             putStrLn "pifpouf"
             --(fire messageDatabase (database))-- est ce que besoin une seule fois?
             --_ <- send mmeSock $ encode (S1APInitialUEMessage 15 EPSAttach "16")
             putStrLn "pafpif"
             --forever $ do
               --putStrLn "doing stuff"
             forkIO $ do
              forever $ do
            --putStrLn "Received something on the eNodeB"
                 messDec <- decode <$> recv ueSock 1024
         
                 (fire messageUE (messDec,ueSock,mmeSock))
            --For the MME
             --forkIO $ do
             forever $  do
                 messDecMME <- decode <$> recv mmeSock 1024
                 (fire messageMME (messDecMME,mmeSock))
                 
             return ()      
                  
      --compile and start network
         --forkIO $ (fire message (messDec,connectionSocket))
        -- putStrLn "Fired something on the eNodeB"
         
      {- putStr "> "
       hFlush stdout
       s <- getLine
       case s of
         "message1" -> fire message 1 --fire corresponding events
         "message2" -> fire message 2
         "messageI" -> fire messageI ()
         "quit" -> return ()
         _ -> putStrLn "Unknown command"
       when (s /= "quit") loop -}
{-----------------------------------------------------
     Event Sources
------------------------------------------------------}
type EventSource a = (AddHandler a, a -> IO())

addHandler :: EventSource a -> AddHandler a
addHandler = fst

fire :: EventSource a -> a -> IO()
fire = snd

{-----------------------------------------------------
     Program Logic
------------------------------------------------------}

-- Set up the event network
setupNetwork :: forall t. Frameworks t =>
   (EventSource (RrcMessage,Socket,Socket), EventSource(S1APMessage, Socket), EventSource(TVar ENBMap))-> IO(TVar ENBMap) -> Moment t ()
setupNetwork (messageUE, messageMME, messageDatabase) database= do

  --Obtain events corresponding to the two commands
  --eMessageUE{-:: Event t (RrcMessage,Socket)-} <- fromAddHandler (addHandler messageUE)
  let
    handler = addHandler messageUE
  eMessageUE{-:: Event t (RrcMessage,Socket)-} <- fromAddHandler handler
  eMessageMME <- fromAddHandler (addHandler messageMME)
  --eDatabase <- fromAddHandler (addHandler messageDatabase)--ou behavior fromChanges
  --bMessageUE <-fromChanges  eMessageUE handler
  --database <-newTVar Map.empty

  let
    
    --How to capture the state? Compare to the slot machine
    --For now, number of messages received is the state
    -- both the eMessage 1 and the emessage2 events add one to the state
    bNbMessages :: Behavior t Int
    eNbMessages :: Event t Int
    (eNbMessages, bNbMessages) = mapAccum 0 . fmap (\f x -> (f x, f x)) $
                     ((addMessage <$ eMessageUE)
                        `union` (addMessage <$ eMessageMME) )
    --Functions to change the state
    addMessage = (+ 1)

    -- State of the eNodeB is one UEContext per UE
    --database = newTVar Map.empty 
    bUeContext :: Behavior t (IO (TVar ENBMap))
    --eUeContext :: Event t (TVar ENBMap)
    --(eUeContext, bUeContext) = mapAccum database  . fmap (\f x -> (f x, f x)) $
           --(((initUEContext ) <$> eMessageRAPreamble))
           -- `union` () )
    eMessageRAPreambleDone = (((initUEContext database) <$> eMessageRAPreamble))
    bUeContext = stepper ( database) eMessageRAPreambleDone

    --current message
    --bCurrentRrcMessage :: Behavior t (RrcMessage,Socket,Socket)
    --bCurrentRrcMessage = stepper (RAPreamble RA_RNTI 0,) (replaceCurrMess <$> eMessageRAPreamble)--change for eMess?

    --replaceCurrMess(message, _,_) = message
    
    
    --bUeContext = stepper ( database) (((initUEContext database) <$> eMessageRAPreamble))--(atomically $ newTVar Map.empty)  (((initUEContext database) <$> eMessageRAPreamble))

    -- Functions that act on the UE context
    initUEContext :: IO(TVar ENBMap) -> (RrcMessage, Socket,Socket) -> IO (TVar ENBMap)
    initUEContext database (message, ueSocket, mmeSocket) = do
      newData <- liftIO $ database
      atomically $ modifyTVar (newData ) (\eNBmap -> Map.insert (ueIdRntiValue message) (defaultUeContext 588) eNBmap )
      --newData <-readTVarIO database
      --return the entry that was created ?
      database
      
      
      --crnti <-genRandId 5 588
      --Map.adjust (modifyCrnti crnti) (ueIdRntiValue message) database
    
    --Inner functions to fire a specific event depending on the one that was received
    --one needeed per incoming message
    eMessageRAPreamble ::Event t (RrcMessage,Socket,Socket)
    eMessageRAPreamble = filterE raPreamble eMessageUE

    raPreamble:: (RrcMessage, Socket,Socket)-> Bool
    raPreamble x = case x of
      (RAPreamble m b, _,_)-> True
      _ -> False

    eMessageRrcCR ::Event t (RrcMessage,Socket,Socket)
    eMessageRrcCR = filterE rrcCR eMessageUE

    rrcCR:: (RrcMessage, Socket,Socket)-> Bool
    rrcCR x = case x of
      (RRCConnectionRequest m b c, _,_)-> True
      _ -> False

    eMessageRrcCC ::Event t (RrcMessage,Socket,Socket)
    eMessageRrcCC = filterE rrcCC eMessageUE

    rrcCC:: (RrcMessage, Socket,Socket)-> Bool
    rrcCC x = case x of
      (RRCConnectionSetupComplete m, _,_)-> True
      _ -> False

  --Stupid MME test
    eMMESocket ::Event t (S1APMessage,Socket)
    eMMESocket = filterE mmeSoc eMessageMME

    mmeSoc:: (S1APMessage, Socket)-> Bool
    mmeSoc x = case x of
      (GetSocket, _)-> True
      _ -> False

    --responses can be sent
    eSendRepRAPreamble :: Event t (IO(RrcMessage, Socket) ) 
    eSendRepRAPreamble =   (apply ((createMessage <$> bUeContext)) eMessageRAPreamble )--(apply (returnMess<$> bMessageUE) eMessageRAPreambleDone) ) -- <$ eMessageRAPreambleDone

    createMessage behaviorContent (message,ueSock,_) = do
      newBe <- liftIO behaviorContent
      map <- readTVarIO newBe
      return (RAResponse RA_RNTI (ueIdRntiValue message) (c_rnti (Map.findWithDefault defaultEmptyContext (ueIdRntiValue message) (map))),ueSock)

    returnMess behavior _ = behavior

  --type UeContext_eNB
    --dummy be (message,_,_) =(Map.findWithDefault defaultEmptyContext (ueIdRntiValue message) (liftIO $ readTVarIO be))
    --type String
    --dummy be (message,_,_) =c_rnti (Map.findWithDefault defaultEmptyContext (ueIdRntiValue message) (liftIO $ readTVarIO be))
    --type RRCMessahe
    --dummy be (message,sock,_) =RAResponse RA_RNTI (ueIdRntiValue message) (c_rnti (Map.findWithDefault defaultEmptyContext (ueIdRntiValue message) (liftIO $ readTVarIO be)))
    --dummy be (message,sock,_) =(RAResponse RA_RNTI 12 "15",sock)
    --dummy ::(TVar ENBMap) -> (RrcMessage, Socket, Socket)-> (RrcMessage,Socket)
    --dummy be (message,sock,_) =(RAResponse RA_RNTI (ueIdRntiValue message) (c_rnti (Map.findWithDefault defaultEmptyContext (ueIdRntiValue message) (liftIO $ readTVarIO be))),sock)                                                                              --dummy2 :: RrcMessage -> (RrcMessage, Socket, Socket) -> (RrcMessage,Socket)
    --dummy2 message (_,sock,_)= (message, sock)
        



      {-do
                                        var <-liftIO $ (readTVarIO <$>behaviorContent)
                                        return (RAResponse RA_RNTI (ueIdRntiValue message) (c_rnti (Map.findWithDefault defaultEmptyContext (ueIdRntiValue message) var)))
-}
    {-mmeSocket :: Behavior t Socket
    eMmeSocket :: Event t Socket
    eMmeSocket = (extractSocket <$> eMMESocket)-- a rassembler ces  2 lignes?
    mmeSocket = stepper dummySocket eMmeSocket

    dummySocket::Socket
    {-dummySocket =  do
      sock<-liftIO (socket AF_INET Stream defaultProtocol)
      return sock-}
                   
    {-(eMmeSocket,mmeSocket) = mapAccum 0 . fmap (\f x -> (f x, f x)) $(extractSocket <$> eMMESocket)-}

    extractSocket:: (S1APMessage, Socket) -> Socket
    extractSocket (message,socket)= socket-}
 
  --case eMessage of
  -- (RAPreamble m, Socket s) -> eMessageRAPreamble m s

    

    --Output: Is printed in the order of definition?
  reactimate $ putStrLn . showNbMessages <$> eNbMessages
  reactimate $ putStrLn . showMessageNumber <$> eMessageUE
  reactimate $ putStrLn . showMessageNumberMME <$> eMessageMME
  --reactimate $ sendResponse (RAResponse RA_RNTI 12 21) <$> eMessageRAPreamble
  reactimate $ sendResponseToRAPreamble <$> eSendRepRAPreamble -- <$> eMessageRAPreamble
  --reactimate $ sendResponseMME (S1APInitialUEMessage 13 EPSAttach "16") <$> eMessageRAPreamble
  reactimate $ sendResponse (RRCConnectionSetup C_RNTI 45 54) <$> eMessageRrcCR
  reactimate $ putStrLn "CR received " <$ eMessageRrcCR
  --reactimate $ sendResponse (RRCConnectii True) <$> eMessageRrcCC
  reactimate $ putStrLn  "ConnectionSetup is complete " <$ eMessageRrcCC
  --test du MME
  reactimate $ sendResponseMME (S1APInitialUEMessage 14 EPSAttach "16") <$>eMessageRrcCC
    --sock <- createSocketThingy <$>eMMESocket
    --(sendResponseMME (S1APInitialUEMessage 12 EPSAttach "16")(extractSocket<$>eMMESocket)) <$ eMessageRrcCC
    --(createSocketThingy (S1APInitialUEMessage 12 EPSAttach "16")<$> eMMESocket <$ eMessageRrcCC)
  reactimate $ putStrLn  "MME Socket detected " <$ eMMESocket
    --add an output event?

    
showNbMessages nbMessages = "Nb of messages received: " ++ show nbMessages
showMessageNumber (number, socket,mmesocket) = "Message from UE " ++ show number ++ " has arrived"
sendResponse message (number,sock,mmeSocket) = do
                             _ <- send sock $ encode message
                             return ()
sendResponseToRAPreamble :: IO (RrcMessage,Socket)-> IO ()
sendResponseToRAPreamble x = do
                             (message, ueSocket)<- x
                              
                             --let message= (RAResponse RA_RNTI (ueIdRntiValue message) (c_rnti (Map.findWithDefault 0 (ueIdRntiValue message)    <$> ( bUeContext))) )
                             
                             _ <- send ueSocket $ encode message --(createMessage message <$> bUeContext)--messageNew
                             return ()


{-createMessage message behaviorContent = do
                                        var <-liftIO $ (readTVarIO <$>behaviorContent)
                                        return (RAResponse RA_RNTI (ueIdRntiValue message) (c_rnti (Map.findWithDefault defaultEmptyContext (ueIdRntiValue message) var)))-}
                                        
showMessageNumberMME (number, mmesocket) = "Message from MME " ++ show number ++ " has arrived"
sendResponseMME message (number, uesock, mmesock) = do
                             --stupid stuff for the dummy
  
  putStrLn "Trying to send to the mme"
    
  _ <- send mmesock $ encode message
  return ()
  
{-createSocketThingy message event rrcmess  = do
  
    --mmeSocket :: Behavior t Socket
    --eMmeSocket :: Event t Socket
    eMmeSocket <- (extractSocket <$> event)-- a rassembler ces  2 lignes?
    _ <- send eMmeSocket $ encode message
    return ()
    --mmeSocket <- stepper dummySocket eMmeSocket
    --return ()
    where
       extractSocket:: (S1APMessage, Socket) -> Socket
       extractSocket (message,socket)= socket-}
   
       {-dummySocket::Socket
       dummySocket =  do
        sock<-socket AF_INET Stream defaultProtocol
        return sock-}
                   
    {-(eMmeSocket,mmeSocket) = mapAccum 0 . fmap (\f x -> (f x, f x)) $(extractSocket <$> eMMESocket)-}
--extractSocket:: (S1APMessage, Socket) -> Socket
 --      extractSocket (message,socket)= socket
   
connectedMMESocket :: HostName -> ServiceName -> IO Socket
connectedMMESocket host port = do
  sock <- socket AF_INET Stream defaultProtocol
  addrInfo <- getAddrInfo Nothing (Just host) (Just port)
  let primary = head addrInfo
  connect sock $ addrAddress primary
  return sock

defaultUeContext :: Int -> UeContext_eNB
defaultUeContext seed = UeContext_eNB {rrcState = RRC_Idle,
  c_rnti = genRandId 5 seed,
  imsi = "0",
  Context.srbIdentity = 0,
  eNBUES1APid = 0,
  ratCapabilities =[(E_UTRA,False)],--default RAT a revoir
  Context.securityKey = 0,
  Context.epsBearerId = 0 }

{-modifyCrnti crnti context = 
  --recuperer le vieux context et en creer un autre
  UeContext_eNB {rrcState = (rrcState context),
  c_rnti = crnti,
  imsi = (imsi context),
  Context.srbIdentity = (Context.srbIdentity context),
  eNBUES1APid = (eNBUES1APid context),
  ratCapabilities =(ratCapabilities context),
  Context.securityKey = (Context.securityKey context),
  Context.epsBearerId = (Context.epsBearerId context)}-}

defaultEmptyContext :: UeContext_eNB
defaultEmptyContext = UeContext_eNB {rrcState = RRC_Idle,
  c_rnti = "0",
  imsi = "0",
  Context.srbIdentity = 0,
  eNBUES1APid = 0,
  ratCapabilities =[(E_UTRA,False)],--default RAT a revoir
  Context.securityKey = 0,
  Context.epsBearerId = 0 }

  
